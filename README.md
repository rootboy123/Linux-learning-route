# Linux学习路线
# 第一章

## 1.1 Linux的特点
* 免费开源。Linux是一款完全免费的操作
系统，任何人都可以从网络上下载到它的源代码
* 模块化程度高。Linux的内核设计分成进
程管理、内存管理、进程间通信、虚拟文件系统、
网络5部分
* 广泛的硬件支持。得益于其免费开源的
特点，有大批程序员不断地向Linux社区提供代
码
* 安全稳定。Linux采取了很多安全技术措
施，包括读写权限控制、带保护的子系统、审计跟
踪、核心授权等
* 多用户，多任务。多用户是指系统资源
可以同时被不同的用户使用，每个用户对自己的资
源有特定的权限，互不影响
* 良好的可移植性。Linux中95%以上的代
码都是用C语言编写的

## 1.2 安装Linux
### 什么是交换分区(swap)？
* 交换分区是一个特殊的分
区，它的作用相当于Windows下的虚拟内存，这个
分区的大小一般设置为物理内存的两倍，但是不管
物理内存有多大，交换分区建议不要超过8GB，因
为大于8GB的交换分区其实并没有多大实际意义。
###什么是boot分区和Grub？
* /boot分区用于放置Linux启动
所用到的文件，如kernel和initrd文件<br>
* Grub是一个系统引导工具，通过
它可以加载内核，从而引导系统启动
###什么是DHCP？
* DHCP是Dynamic Host
Configuration Protocol的简写，中文称为动态主机配
置协议。在TCP/IP网络中，每台主机都需要有IP地
址才能与其他主机通信，在一个大规模的网络中，
如果由管理员手动地对每一台主机进行IP地址配置
是不现实的。由此也就产生了DHCP协议，可用它
来对网络节点上的主机进行IP地址配置

### 1.3 安装Linux系统（RedHat/CentOs）


### 1.4 使用终端模式登录
* tty：linux定义了6个tty终端，Ctrl+Alt+F1进入第一个终端，使用组合键
Ctrl+Alt+F2进入第二个终端，其他终端的组合键以
此类推，在Linux系统中，在特殊文件目录/dev下有一
些文件与之对应，比如/dev/tty1、/dev/tty2等，从
tty1到tty6又称为虚拟终端。如果想回到桌面模式，
只需要使用组合键Ctrl+Alt+F7即可
> 注意：如果系统设置默认启动的时候不启动图形界面
（下一小节中我们会提到系统中的一个重要的概
念：runlevel，当runlevel为3时，则不启动图形界
面），在这个情况下，tty7是不可用的，这时候要
想从终端字符界面进入图形界面就需要使用startx这
个命令了
* 在平时的工作中，当你登录到
系统中进行操作后，一定要记得在离开终端前要输
入exit命令退出当前的登录用户，防止他人利用该
账户进行操作而造成麻烦。

-----------
如下图登录界面：
```
CentOS release 5.5 (Final)
Kernel 2.6.18-194.el5 on an i686
Localhost login:root
Password:
Last login: Tue Oct 9 22:07:00 2012
[root@localhost ~]#
```
------------
* 第一行是发行版的名称（CentOS）和版
本号（5.5）；第二行是内核版本（2.6.18-
194.el5），以及当前运行的硬件平台（i686）；第
三行是主机名（localhost），login后面等待用户输
入，这里输入“root”；第四行等待输入root用户的密
码；第五行是当成功登录时，系统会显示出该用户
上次成功登录的时间；第六行显示登录成功后用户
和主机名以及所在的目录，“~”是用户home目录
（又叫“用户家目录”）的简写。最后的“#”是一个提
示符，出现“#”说明目前的用户是有超级权限的root
用户，而一般用户的提示符是“$”。

~~下一章：1.4.4~~


#开始学习Linux命令
1.显示日期 date
```
[root@localhost ~]# date
Thu Oct 11 23:05:54 CST 2012
```
2.列出目录内容 ls
```
[root@localhost ~]# ls
anaconda-ks.cfg Desktop install.log install.log.syslog
```
>使用root登录系统后，使用ls命令可以列出当前
目录下的内容，上面的命令显示了anaconda-
ks.cfg、Desktop、install.log、install.log.syslog四个
内容。
```
[root@localhost ~]# ls -l
total 60
-rw------- 1 root root 954 Oct 7 21:02 anaconda-ks.cfg
drwxr-xr-x 2 root root 4096 Oct 7 22:53 Desktop
-rw-r--r-- 1 root root 30975 Oct 7 21:02 install.log
-rw-r--r-- 1 root root 4492 Oct 7 20:59 install.log.syslog
```
>通过这个例子可以知道，ls-l的作
用是详细显示当前目录下的所有文件。<br>如果只是想详细显示其中一个文件，那么该怎
么做呢？只要加上需要显示的文件就可以了。这说
明ls命令除了-l选项之外，还可以在后面再加参数。
比如下面是添加了anaconda-ks.cfg参数：
```
[root@localhost ~]# ls -l anaconda-ks.cfg
-rw------- 1 root root 954 Oct 7 21:02 anaconda-ks.cfg
```

3.显示文件内容 cat
>anaconda-ks.cfg是一个文本文件，那么里面的内
容是什么呢？可以使用cat命令来显示。
```
[root@localhost ~]# cat anaconda-ks.cfg
# Kickstart file automatically generated by anaconda.
......(
略去内容)....
```
#系统启动流程
##系统引导概述
* 首先，计算机会加载BIOS，这是计算机上最接
近硬件的软件，各家主板制造商都会开发适合自己
主板的BIOS，而BIOS中一项很重要的功能就是对
自身的硬件做一次健康检查，只有硬件没有问题，
才能运行软件，记住，操作系统也是一种软件。这
种通电后开始的自检过程被称为“加电自检”，英文
中称为Power On Self Test，简称POST。如果所有
的硬件自检通过，一般都会发出一次“滴”的短声
* 机器自检通过后，下面就要引导系统了。这个
动作是BIOS设定的，BIOS默认会从硬盘上的第0柱
面、第0磁道、第一个扇区中读取被称为MBR的东
西，即主引导记录。一个扇区的大小是512字节，
存放的内容是一段引导程序和分区信息，其中引导
程序部分占用446字节，另外64字节是磁盘分区表
DPT，最后两字节是MBR的结束位。这512字节的
空间内容是由专门的分区程序产生的，比如说
Windows下的fdisk.exe，或者Linux下的fdisk命令，
所以它不依赖于任何操作系统，而MBR中的引导程
序也是可以修改的，所以可以利用这个特性实现多
操作系统共存。由于RedHat、CentOS默认会使用
Grub作为其引导操作系统的程序，而Grub本身又比
较大，所以常见的方式是在MBR中写入Grub的地
址，这样系统实际会载入Grub作为操作系统的引导
程序。
* 经过了上面的步骤，第三步就是顺理成章地运
行Grub了。Grub最重要的功能就是根据其配置文件
加载kernel镜像，并运行内核加载后的第一个程
序/sbin/init，这个程序会根据/etc/inittab来进行初始
化的工作。其实这里最重要的就是根据文件中设定
的值来确定系统将会运行的runlevel，默认的
runlevel定义在“id:3:initdefault:”中，其中的数字3说
明目前的运行级别定义为3
* 第四步，Linux将根据/etc/inittab中定义的系统初
始化配置si::sysinit:/etc/rc.d/rc.sysinit执
行/etc/rc.sysinit脚本，该脚本将会设置系统变量、
网络配置，并启动swap、设定/proc、加载用户自定
义模块、加载内核设置等。
* 第五步是根据第三步读到的runlevel值来启动对
应的服务，如果值为3，就会运行/etc/rc3.d/下的所
有脚本，如果值为5，就会运行/etc/rc5.d/下的所有
脚本。
* 第六步将运行/etc/rc.local，第七步会生成终端或
X Window来等待用户登录。

##Linux系统运行级别
* runlevel
究竟是什么呢？我们说Linux默认有7个运行级，从
运行级0到运行级6，每一个运行级所对应的含义如
下：
>运行级0：关机。<br>
运行级1：单用户模式，系统出现问题时可使用
这种模式进入系统维护，典型的使用场景是在忘记
root密码时可进入此模式修改root密码。<br>
运行级2：多用户模式，但是没有网络连接。<br>
运行级3：完全多用户模式，这也是Linux服务<br>
器最常见的运行级。
运行级4：保留未使用。<br>
运行级5：窗口模式，支持多用户，支持网络。<br>
运行级6：重启。<br>
* 任何时候Linux只能在一种runlevel下运行。那么
不同的runlevel之间到底有什么区别呢？上一节中提
到，系统在启动的过程中会根据/etc/inittab中的设定
读取runlevel的数值X，并相应地读取和运
行/etc/rcX.d（X代表0～6）下所有的脚本。
```
[root@localhost ~]# ll /etc/rc3.d/
total 288
......(
略去内容)......
lrwxrwxrwx 1 root root 15 Oct 7 20:52 K15httpd -
> ../init.d/httpd
lrwxrwxrwx 1 root root 13 Oct 7 20:55 K20nfs -
> ../init.d/nfs
......(
略去内容)......
lrwxrwxrwx 1 root root 18 Oct 7 20:50 S08iptables -
> ../init.d/iptables
lrwxrwxrwx 1 root root 17 Oct 7 20:52 S10network -
> ../init.d/network
......(
略去内容)......
```
> 注意看每行中第9列的内容，分别是以K或S开
头、后跟两位数字、再接服务名的文件，其实它们
链接的是上层init.d目录中的服务脚本。系统在启动
过程中，会首先运行以K开头的脚本，全部运行完
毕后再运行以S开头的脚本，在运行所有K开头的脚
本时，又会严格按照K后面的数字大小依次来运
行，也就是数字小的先运行，数字大的后运行。同
样，在运行S开头的脚本时，也是按照这个原则进
行的，即先运行数字小的脚本，再运行数字大的脚
本。K和S的意思分别是停止（kill）和启动
（start），只要定义好不同运行级需要启动和停止
的服务，就可以让系统在不同的运行级下启动和关
闭不一样的服务。<br>再来对比一下/etc/rc1.d下的关于
network项内容：
```
[root@localhost ~]# ll /etc/rc1.d/
total 288
......(
略去内容)......
lrwxrwxrwx 1 root root 17 Oct 7 20:52 K90network -
> ../init.d/network
......(
略去内容)......
```
> 在运行级为1的时候，network是在开机启动的过
程中被关闭的（K90network），而在运行级为3的
时候，network则是被开启的（S10network）。

##服务启动脚本
* 上节在介绍Linux运行级时，谈到在Linux启动过
程中会使用K或S开头的脚本关闭或启动相关服务，
那么这是怎么做到的呢？本节将通过一个脚本帮助
大家理解。当然因为这里还没有讲到Shell编程的内
容，所以只做非常简单的讲解。
----------------
```
#!/bin/bash
#
一个bash
脚本开始的标记，必须是用“#!/bin/bash
”开头，含义是提示系统在运行该脚本时使用
/bin/bash
作为执行该文件的解释器
# /etc/rc.d/init.d/atd
#
说明自己的绝对路径
# Starts the at daemon
#
# chkconfig: 345 95 5
#345
是说在运行级是345
的时候，默认开启atd
，也就是Start
#95
是说明当默认设置为on
的时候，运行优先级定为95
#5
是说明当默认设置为off
的时候，停止优先级定为5
# description: Runs commands scheduled by the at command at the time
# specified when at was run, and runs batch commands when the load
# average is low enough.
# processname: atd
# Source function library.
. /etc/init.d/functions
#
使用“.
”命令包含文件，可以使用/etc/init.d/functions
中定义的函数
# pull in sysconfig settings
[ -f /etc/sysconfig/atd ] && . /etc/sysconfig/atd
test -x /usr/sbin/atd || exit 0
RETVAL=0
#
# See how we were called.
#
prog="atd"
start() {
# Check if atd is already running
if [ ! -f /var/lock/subsys/atd ]; then
echo -n $"Starting $prog: "
daemon /usr/sbin/atd $OPTS && success || failure
RETVAL=$?
[ $RETVAL -eq 0 ] && touch /var/lock/subsys/atd
echo
fi
return $RETVAL
}
#
定义start
函数
stop() {
echo -n $"Stopping $prog: "
killproc /usr/sbin/atd
RETVAL=$?
[ $RETVAL -eq 0 ] && rm -f /var/lock/subsys/atd
echo
return $RETVAL
}
#
定义stop
函数
restart() {
stop
start
}
#
定义restart
函数，实际调用时，先执行stop
函数后执行start
函数
reload() {
restart
}
#
定义reload
函数，实际调用时，就是执行restart
函数
status_at() {
status /usr/sbin/atd
}
#
定义status_at
函数，实际调用时，是调用/etc/init.d/functions
中定义的函数status
，
参数为/usr/sbin/atd
，也就是查询atd
的运行状态
case "$1" in
start)
start
;;
stop)
stop
;;
reload|restart)
restart
;;
condrestart)
if [ -f /var/lock/subsys/atd ]; then
restart
fi
;;
status)
status_at
;;
*)
echo $"Usage: $0 {start|stop|restart|condrestart|status}"
exit 1
esac
exit $?
exit $RETVAL
```
-----------------
> 上面的脚本实际上是/etc/init.d/atd中的内容，我
在脚本中做了一些注释来简单讲解脚本的处理过
程。当atd设置为启动时，将会在对应
的/etc/rcX.d（X代表0～6）目录下显示：S95atd-
>../init.d/atd，系统根据第一个字母S判定atd需要启
动，然后会调用命令/etc/init.d/atd start；当atd设置
为关闭时，将会在对应的/etc/rcX.d目录下显示：
K05atd->../init.d/atd，系统根据第一个字母K判定atd
需要关闭，然后调用命令/etc/init.d/atd stop，这样就
实现了对atd的启停控制，其他服务也是同样的原
理。

## Grub介绍
* 事实上
Grub可以引导多个操作系统。早先Linux的引导程
序是lilo，含义为Linux Loader，这是ext2文件系统
中特有的引导程序
* 在之前的系统启动流程中提到，计算机在启动
时，BIOS默认会从硬盘上的第0柱面、第0磁道、第
一个扇区中读取512字节的数据来引导系统启动，
但是Grub这个程序远远大于512字节，这一个扇区
又如何能够载下Grub所有的内容呢？为了解决这个
问题，实际上Grub的启动是分成两段完成的。第一
段以stage1作为主引导程序，它的主要任务是定位
和装载第二段引导程序，并转交控制权，即
stage2。Grub目录中的内容如下：
-----------------------------
```
[root@localhost grub]# cd /boot/grub/
[root@localhost grub]# ls -l
total 257
-rw-r--r-- 1 root root 63 Oct 7 21:02 device.map
-rw-r--r-- 1 root root 7584 Oct 7 21:02 e2fs_stage1_5
-rw-r--r-- 1 root root 7456 Oct 7 21:02 fat_stage1_5
-rw-r--r-- 1 root root 6720 Oct 7 21:02 ffs_stage1_5
-rw------- 1 root root 573 Oct 7 21:02 grub.conf
-rw-r--r-- 1 root root 6720 Oct 7 21:02 iso9660_stage1_5
-rw-r--r-- 1 root root 8192 Oct 7 21:02 jfs_stage1_5
lrwxrwxrwx 1 root root 11 Oct 7 21:02 menu.lst -
> ./grub.conf
-rw-r--r-- 1 root root 6880 Oct 7 21:02 minix_stage1_5
-rw-r--r-- 1 root root 9248 Oct 7 21:02 reiserfs_stage1_5
-rw-r--r-- 1 root root 55808 Mar 13 2009 splash.xpm.gz
-rw-r--r-- 1 root root 512 Oct 7 21:02 stage1
-rw-r--r-- 1 root root 104988 Oct 7 21:02 stage2
-rw-r--r-- 1 root root 7072 Oct 7 21:02 ufs2_stage1_5
-rw-r--r-- 1 root root 6272 Oct 7 21:02 vstafs_stage1_5
-rw-r--r-- 1 root root 8904 Oct 7 21:02 xfs_stage1_5
```
> 注意一下，有一个stage1的文件，大小为512字
节，正好是一个扇区的大小。其实这不是一个巧
合，stage1确实是MBR的一个副本。还可以看到有
很多文件是以stage1_5结尾的，事实上这些文件是
各种文件系统的驱动文件，当stage1从不同的文件
系统中读取stage2时将用到这些驱动文件。下面是系统
安装过程中自动生成的配置：
-----------------
```
# grub.conf generated by anaconda
#
# Note that you do not have to rerun grub after making changes to this
# NOTICE: You have a /boot partition. This means that
# all kernel and initrd paths are relative to /boot/, eg.
# root (hd0,0)
# kernel /vmlinuz-version ro root=/dev/sda3
# initrd /initrd-version.img
#boot=/dev/sda
default=0
timeout=5
splashimage=(hd0,0)/grub/splash.xpm.gz
hiddenmenu
title CentOS (2.6.18-194.el5)
root (hd0,0)
kernel /vmlinuz-2.6.18-
194.el5 ro root=LABEL=/ rhgb quiet
initrd /initrd-2.6.18-194.el5.img
```
-------------------------------
> 其中，default=0的含义是默认从第一个title处启
动。这里的配置文件中只有一个title项，但是如果
还有第二个title项，则可以配置默认从第二个title处
引导系统，只要把default改为1就可以了（注意这里
的计数是从0开始的）
> timeout=5的含义是显示这个title项时，同时有5
秒倒计时，5秒内可以按回车键提前从默认的启动
项中启动，也可以按上下键立即停止倒计时，选定
一个title，然后按回车键确认从选定的title中启动。
也可以选定某一个title后，按e键进入编辑模式，这
样可以即时对Grub进行配置，但是这时的配置并不
会写入配置文件中，而只是当时生效。
> splashimage是指定启动时的背景图像。如果系
统使用的是sata磁盘，则命名规则为：第一块磁盘
是sda，第二块磁盘是sdb，以此类推。对磁盘进行
分区后的分区命名规则是，第一个磁盘的第一个分
区是sda1，第一个磁盘的第二个分区是sda2，第二
个磁盘的第一个分区是sdb1，第二个磁盘的第二个
分区是sdb2。而Grub使用hd0代表第一块磁盘，而
这里（hd0,0）的含义是第一块磁盘的第一个分区。
所以(hd0,0)/grub/splash.xpm.gz的绝对路径就
是/boot/grub/splash.xpm.gz，这是一个压缩文件，
Grub在启动时会自动对该文件做解压缩.
> hiddenmenu是设置启动时是否显示菜单。
> title是系统引导时显示的名字，这只是一种识别
性的文字，可以任意修改。文件的最后3行是相互
关联的，第一行root（hd0,0）参数指定了内核放置
的分区；第二行kernel/vmlinuz-2.6.18-194.el5 ro
root=LABEL=/rhgb quiet指定了内核的路径，表示
内核是（hd0,0）分区中的vmlinuz-2.6.18-194.el5文
件，ro root=LABEL=/rhgb quiet是启动内核时向内
核传入的参数；最后一行initrd/initrd-2.6.18-
194.el5.img指定了initrd文件的路径是（hd0,0）中的
initrd-2.6.18-194.el5.img文件。
> 这里第一次提到initrd文件，其英文含义是boot
loader initialized RAM disk，也就是boot loader用于
初始化的内存磁盘，是系统启动时的临时文件系
统，kernel通过读取initrd来获得各种可执行文件和
设备驱动，并挂载真实的文件系统，然后卸载这个
临时文件系统

## man文件类型
* 我们在日常生活中，习惯于将不同的东西分门
别类地存放，比如说在上学的时候会习惯性地把数
学类的辅导书放在一起，英语类的辅导书放在一
起，这样可以方便寻找。同样，在Linux下也有这
样的习惯，其中规定了以下9个man文件的种类：
-------------------------
* 1.常见命令说明
* 2.可调用的系统
* 3.函数库
* 4.设备文件
* 5.文件格式
* 6.游戏说明
* 7.杂项
* 8.系统管理可用命令
* 9.与内核相关
> 有些命令会在好几个种类中存在，可以使用
man-f来查询要找的命令存在于哪些man文件中。例
如：
```
[root@localhost ~]# man -f reboot
reboot (2) - reboot or enable/disable Ctrl-Alt-
Del
reboot [halt] (8) - stop the system
```
